
import math
import random
import time
from collections import Counter
from colorama import Back, Style

#from board import MAX_TRIES
#from wordle import getValidMoves
#from wordle import getValidMoves, validWords
# file structure generated by chat GPT, implemented by the team
# Resources: https://ai-boson.github.io/mcts/

MAX_TRIES = 20
NUM_BOARDS = 8

#Gets one of the words from the list randomly, used for when picking the wordle word
def getRandWord():
    index = random.randrange(0, len(validWords))
    return validWords[index]

#Evaluates the word guessed based on the correct word
def evaluate(word1, word2):
  #if the guess letter is in the right spot add 2 to score, if its just in the word add 1 to score
  score = 0 
  for i in range(5):
      if word1[i] == word2[i]:
          score += 2
      elif word1[i] in word2:
          score += 1
  return score #If you evaluate team and meet it returns 7 instead of 6

#Gets all the words it could be based off the information we currently have
def get_valid_moves(valid_word_list, guess, correct_word):
    validMoves = []
    invalidMoves = []
    greys, greens, yellows = get_bad_letters(guess, correct_word)
    for word in valid_word_list: #look through all words
        
        goodWord = True
        if word == guess:
           goodWord = False
        if greens:
           for letter in greens:
              if word[letter[1]] != letter[0]:
                 goodWord = False
        if greys:
          for letter in greys:
              if letter in word:
                goodWord = False
        if yellows:
           for letter in yellows:
              if word[letter[1]] == letter[0]:
                 goodWord = False
        
        if goodWord:
          validMoves.append(Node(word))
        # if 0 in score_word(word, correct_word):
        #    invalidMoves.append(word)
        # else:
        #   validMoves.append(Node(word))
    #print(len(validMoves))

    return validMoves

#Same as get_valid_moves but for all the boards
def get_game_valid_moves(boards, guess):
  valid_moves =[]
  for board in boards:
      valid_moves.extend(get_valid_moves(node_to_string(board.valid_words), guess, board.correct_word))
  valid_moves = list(set(node_to_string(valid_moves)))
  valid_moves = [Node(move) for move in valid_moves]
  return valid_moves

#This class is the game, allows us to have multiple boards for octordle
class Game:
  def __init__(self, validWords):
      self.boards = [Board(validWords) for _ in range(NUM_BOARDS)]
  def play(self, word_played):
     for board in self.boards:
        board.play(word_played)

#A single wordle board, one game of wordle
class Board:
  def __init__(self, valid_words):
    self.valid_words = [Node(valid_word) for valid_word in valid_words]
    self.correct_word = getRandWord()
    self.solved = False
    self.board = [[] for x in range(MAX_TRIES+1)] #This is the wordle boards
    self.guesses = []
    self.current_guess = Node("adieu")
    self.guess_number = 0
    self.play(self.current_guess.word) #We start with adieu every time so we automatically play it when the board is created
  
  #Plays a move based on a guess
  def play(self, word_played):
    if not self.solved:
      if word_played in validWords:
        self.board[self.guess_number] = word_played
        #Change valid word list to shorten runtime
        self.valid_words = get_valid_moves(node_to_string(self.valid_words), word_played, self.correct_word)
        evaluate(word_played, self.correct_word)
        #if (sum(evaluate(word_played, self.correct_word)) < 10):
        #self.solved = True
        self.guesses.append(word_played)
        self.guess_number += 1


def get_bad_letters(guess, correct):
  bad_letters = []
  greens = []
  yellows = []
  # count_correct = Counter(correct)
  # count_guess = Counter(guess)
  for i in range(5):

          if guess[i] not in correct:
             bad_letters.append(guess[i])
          elif guess[i] == correct[i]:
             greens.append((guess[i], i))
          elif guess[i] in correct:
             yellows.append((guess[i], i))
  return bad_letters, greens, yellows

#Turns a list of Nodes into a list of strings for the words
def node_to_string(node_list):
  string_list = []
  for x in node_list:
    string_list.append(x.word)
  return string_list 

#Each word is its own Node
class Node:
  def __init__(self, word, parent = None):
    self.word = word
    self.parent = parent
    self.children = []
    self.visits = 0
    self.value = 0

  def best_child(self):
    """Return the child with the best UCT value."""
    return max(self.children, key=lambda child: child.uct_value(self.visits))

  def uct_value(self): #Total visits will always be self.visits (Idk if it is correct)
      """Calculate the UCT value for this node."""
      """Adapted from: https://ai-boson.github.io/mcts/"""
      if self.visits == 0:
          return float('inf')  # Ensure unvisited nodes are prioritized
      return self.value / self.visits + 1.41 * (math.sqrt(math.log(self.parent.visits) / self.visits))
      


class MCTS:
    def __init__(self, initial_game):
      self.game = initial_game
      self.root = self.game.boards[0].current_guess
      self.children = get_game_valid_moves(self.game.boards, self.root.word)

    def select(self, node):
        """Select a node to explore based on UCT."""
        while node.children:
            node = node.best_child()  # Traverse to the best child
        return node

    def expansion(self, game):
      """The goal of evaluate is to find the most promising child node and simulating a game based on that node"""
      #Finds the most promising child node and indicates it has been visited
      top_score = 0
      best_child = None
      i = 0
      #setting max amount of seconds to expand
      max_time = 20

      #start timer
      start_time = time.time()
      for child in self.children:
          # update timer
          current_time = time.time() - start_time
          # check time
          if current_time >= max_time:
             return best_child.word

          i+=1
          #print(i, "/", len(self.children), end = '')
          score = 0
          child.children = get_game_valid_moves(self.game.boards, self.root.word)
          for subchild in child.children:
              score += evaluate(child.word, subchild.word)
          if score > top_score:
            top_score = score
            best_child = child
      print(best_child.word)
      return best_child.word

def eval(game, guessNum):
        bad_boards = []
        for board in game.boards:
          print(board.correct_word)
          for pastGuessWord in board.board:
            if pastGuessWord:
                for i in range(5):
                  if pastGuessWord[i] == board.correct_word[i]:
                    print(Back.GREEN + pastGuessWord[i], end = '')
                  elif pastGuessWord[i] in board.correct_word:
                    print(Back.YELLOW + pastGuessWord[i], end = '')
                  else:
                    print(Back.WHITE + pastGuessWord[i], end = '')
                  
                print(Style.RESET_ALL)
          for i in range(MAX_TRIES - guessNum):
              print(Back.WHITE+ '_____', end = '')
              print(Style.RESET_ALL)
          if board.board[guessNum-1] == board.correct_word:
             bad_boards.append(board)
        for board in bad_boards:
           game.boards.remove(board)   


# TESTING

if __name__ == "__main__":
    wordFile = open('words.txt', 'r')
    validWords = wordFile.read()
    validWords = validWords.split('\n')
    wordle_game = Game(validWords)
    # monte_carlo = MCTS(wordle_game)
    # best = monte_carlo.expansion(monte_carlo.root)
    while len(wordle_game.boards) > 0:
        monte_carlo = MCTS(wordle_game)
        best = monte_carlo.expansion(monte_carlo.root)
        wordle_game.play(best)
        eval(wordle_game, wordle_game.boards[0].guess_number)
        
        #print(best, wordle_board.correct_word)
    print("You won")
    # wordle_board.play(best)
    # eval(wordle_board, wordle_board.guess_number)
    # print(monte_carlo.root.best_child().word)
